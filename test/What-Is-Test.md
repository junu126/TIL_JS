# 테스트란?

React에서 사용하는 테스트 툴인 `Jest`와 `enzyme`를 공부해 보았다.

`jest`는 테스트 프레임워크로 빠르고 React와 호완성이 좋다. 그리고 `enzyme`는 테스트 라이브러리로 jest와 함께 사용된다.

나는 처음에 왜 테스트 코드를 작성하는지 생각했다. 궂이 귀찮게 코드를 적어야 할까 싶고, 내가 안틀리면 되지 싶었다. 하지만 큰 프로젝트를 경험하고 협업을 하며 느꼈다. `테스트는 꼭 필요하다.`

테스트 코드를 적어주게 되면 여러 이점이 있다. 먼저 `버그 방지`가 가능하다.

## 버그방지

테스트 코드를 작성하는 이유 중 가장 옳바르다고 생각된다. 나의 코드를 테스트하면서 버그를 찾고, 버그를 고쳤을 때 통과할 만한 코드를 작성 할 수 있게된다.

## 어떻게

또 테스트는 단위적으로 이루어져야한다. `단위 테스트`라고 하는 용어가 있다. 단위 테스트는 모듈이나 애플리케이션 안에 있는 개별적인 코드 단위가 예상대로 작동되는지 확인하는 반복적인 행위이다.  
단위 테스트의 중요한 특징을 몇가지 뽑아보면 `테스트 들은 서로 분리`되어 있고, `실행은 자동화`되며 애플리케이션의 같은 부분을 테스트하는 테스트들은 `그룹화되어 한 번에` 처리된다는 것이다.

테스트 코드들은 서로 분리되어 있고, 테스트 되고 있는 코드와도 분리되어 있기에 개별적으로 동작한다. 그렇기에 특정 부분만 따로 테스트가 가능하게 해준다.

이때 `왜 단위 테스트`를 하는 가? 라는 의문이 들 수 있다. 단지 프로젝트에서 "내 코드가 제대로 동작하는지 확인하는 것" 이라는 명백한 이유 외에도 몇 가지 장점이 있다. 단위테스트를 통해 `코드가 어떻게 작성하는지 생각`하는데 도움을 준다. 또한 코드의 단위를 작게 줄일 수 있다. 그리고 문제를 빨리 발견하고, 변화를 쉽게하며 통합을 간단하게 하고 설계를 개선 가능하다.

## 클린코드

현업에서 코드를 작성하다보면 테스트코드가 없이 구현되는 경우는 거의 없다. 왜냐하면 프로젝트 일정이 정해졌다고 해서 로직을 먼저 구현하게 되면 나중에 유지보수 측면에서 큰 문제가 발생하기 때문이다. 기존의 로직에 영향을 주지 않고 구현하다 보면 사이드 이펙트가 많이 발생하게 된다. 이렇게 되다보면 결국 유지보수를 위한 시간에 테스트 코드를 작성하게 되기 때문이다.

우리는 클린코드를 적용시켜야한다. 클린코드가 우선순위에서 밀려나서는 안되는 이유를 나열해 보겠다. 첫 번째는 `유지보수하기 좋은 코드`를 만들기 위함이다. 프로그래머 작업 중 가장 많은 시간을 사용해야 하는것이 바로 유지보수이다. 유지보수를 위한 코드를 구현하면 서비스의 성패를 좌우할 수 있다. 유지보수를 위해서는 클린 코드를 작성해야 한다. 두 번째는 `온갖 변화에 대응할 수 있는 핵심 능력`을 갖고 있어야 한다. 서비스를 운영하며 필연적으로 발생하기 마련인 기능 추가와 버그 수정, 레거시 코드(**테스트가 불가능하거나 어려운 코드**) 리뷰 및 수정 작업과 같은 변화 자체에 확장성 있게 대응하려면 클린 코드에 대한 이해와 작성 능력이 필수이다. 변화를 피할 수 없으면 제대로 대응해야한다. 마지막으로 `프로젝트 협업 능력 향상`이다. 읽기 좋은 클린 코드를 작성함으로서 오는 장점은 개인이 아니라 협업 대상 모두에게 적용된다. 큰 프로젝트 일 수록 코드 작성 능력을 가진 개발자의 기여도는 높을 수 밖에 없다.

## 테스트 코드 설계

지금까지 단위테스트에 대하여 짧게 나마 정리해보았다. 그럼 이제부터 테 스트 코드를 작성하기 전에 해야하는 `테스트 코드 설계`에 대하여 이야기해보는 시간을 갖겠다. 테스트 코드를 작성할 때 실제 코드 로직을 보지 않고 타겟의 속성이나, 메서드명 만으로도 잘 읽을 줄 알아야 하기에 `가독성` 있고 `일관성 있는 코드`가 필요하다고 한다. 일정한 규칙을 세우고 테스트 코드를 일관성있게 만들면 실제 코드의 수정이 필요하거나 테스트 에러가 발생했을때, **어디서 무엇을 어떻게 해야 수정 할 수 있을지를 금방 파악하고 대응할 수 있기 때문에 유지보수 측면세어 좋다.** 따라서 테스트 코드 설계 규칙을 정의해보도록 하겠다.

### 1. 시각 및 기능적으로 효율적인 테스트 그룹 만들기.

테스트 코드를 작성하기 시작할때 가장 첫번째로 해야하는 일은 일관성 있는 구조로 테스트 코드를 묶어서 관리하는 일 이다. 따라서 간단한 구조를 잡는다. 나는 **설계**를 할때의 구조를 3뎁스 이상 들어가지 못하도록 설정하였다.
- 3뎁스를 지키며 테스트 작성.
  - 객체명 -> 분류(#) -> 테스트 순으로 작성  
다음은 예제 코드이다.

```javascript
// 제목
describe('객체명 / 파일명', () => {
  // 부제목
  describe('# 분류 (역할별)', () => {
    // 테스트
    it('테스트 내용 설명', () => {
      // given
      // when
      // then
    });

    context('일부 테스트가 반복될 때' () => {
      it('테스트 내용 설명', () => {
        // given
        // when
        // then
      });
      
      it('테스트 내용 설명', () => {
        // given
        // when
        // then
      });
    });
  });
});
```

### 2. 부제목은 '#분류명'으로하며, 기준은 유사한 성격끼리 하도록 함.
분류하여 부제목을 적는 예시를 몇개 들어보면 `UI컴포넌트`와 단지 `기능`을 명세한( EX - lib/styleSheet.ts )파일을 들 수 있다.  
`기능`을 명세한 styleSheet.ts는 독립적인 함수들을 모아놓은 객체라 간단히 메서드 명으로 분류된다.  
`UI 컴포넌트`인 App.tsx는 UI Component 객체라 유사한 역할을 하는 메서드끼리 분류한다. 예를 들면 `onClick`메소드, `onChnage`메소드, `UI` 등등 여러 메소드와 UI 컴포넌트를 분류할 수 있다.

### 3. given의 중복을 없애기.
전체적으로 테스트코드는 given이 가장 길게 적힌다. 이때 그룹을 먼저 지어서 테스트 코드를 적다보면 `유사한 성격으로 묶은 그룹`이기 때문에 전제조건 또한 유사해서 given이 계속 비슷하게 작성된다. 이때 `hook메서드`나 `상위 그룹핑 공간에 정의한 변수`들을 어떤 기준으로 분리 했는지 이해할 수 있다.

> hook메서드: `before`, `beforeEach`, `after`, `afterEach`등 각 scope마다 테스트 케이스 호출 전후로 실행할 코드를 컨트롤 해줌.

hook 메서디를 이용하면 `테스트 코드 안의 복잡한 given의 중복을 제거`가능하다.

### 4. 테스트 더블 객체 및 별도 테스트
UI 컴포넌트 객체 안에서 구성한 메소드들은 `각기 다른 수준으로 추상화`가 되어있다. 그리고 하위레벨의 메서드는 상위레벨의 메서드 안에서 호출되는 식으로 의존하고 있다. `상위로 갈 수록 다른 메서드에 의존해 구성되는 경우가 대부분.` 이때 테스트 하기가 힘들다. 이런 상황에 테스트 더블을 사용하면 된다.

> 테스트 더블 객체: `spy`, `stub`등 이 있으며 원래 메소드에 덧 붙여 사용할 때 사용됨.

이때 테스트 더블을 남용하면 깨지기 쉬운 테스트가 된다. 따라서 `stub을 사용해서 실제코드가 호출 되지 않은 메서드에 한해 별도로 테스트를 진행`하면 좋다. 그렇게 하다보면 테스트 더블이 생각보다 많아진다. 이를 줄이는 방법을 고안해야한다.
