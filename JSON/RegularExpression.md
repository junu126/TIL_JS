# 정규 표현식

정규표현식은 문자열에 나타나는 특정 문자 조합과 대응시키기위해 사용되는 패턴입니다.

자바스크립트에서, 정규표현식 또한 하나의 객체입니다. 이 패턴들은 RegExp의 Exec 메소드와 test 메소드, 그리고 String의 match메서드,   replace메소드, serch메서드, split 메소드와 함께 사용됩니다.

# 만드는 방법
정규식을 만드는 방법에는 리터럴을 사용하는 방법과, RegExp 객체의 생성자 함수를 호출하는 방법으로 총 2가지가 있습니다. 

리터럴을 이용하는 방법은 슬래쉬(`/`)로 감싸는 패턴 입니다.  
> `var re = /ab+c/;`  

정규식 리터럴은 스크립트가 불러와 질때 컴파일 됩니다. 만약 정규식이 상수라면 리터럴 방식을 사용하는 것이 효율을 상승시킬 수 있습니다.

다음 방법은 RegExp 객체의 생성자 함수를 호출하는 방법입니다.
> `var re = new RegExp("ab+c");`

생성자 함수를 사용하면 실행 시점에서 컴파일 됩니다. 정규식의 패턴이 변하는 경우와 사용자의 입력과 같은 다른 출처로부터 패턴을 가져와야 하는 경우에 생성자 함수를 이용하는 것이 좋습니다.

# 정규식 패턴
정규식 패턴은 `/abc/` 같이 단순 문자로 구성될 수도있고, `/ab*c/` 또는 `/Chapter(\d+)\.\d*/`와 같이 단순문자와 특수문자의 조합으로 사용될 수 도있습니다.

---
## 단순 패턴
단순 패턴은 문자열을 있는 그대로 대응시키고자 할 때 사용합니다. 예를 들어 `/abc/`라는 패턴은 문자열에서 `abc`라는 문자들이 모두 함께 순서대로 나타나야 합니다. 

예를 들면 "Hi, do you know your `abc`'s?" 와 "The latest airplane designs evolved from sl`abc`raft."와 같은 예제에서 `abc`가 나왔던 부분문자열 abc에 대응될 것 입니다. 하지만 "Gr`ab c`rab"이라는 문자열에서 `ab c`라는 부분 문자열을 포함하고 있지만 정확하게 포함되지 않았기 때문에 대응되지 않습니다.

---
## 특수 문자 사용
'있는 그대로의 대응'을 넘어서 그 이상의 대응을 필요로 할 때, 패턴에 특수한 문자를 포함시킵니다. 예를 들어 `/ab*c/` 패턴은 'a'문자 뒤에 0개 이상의 'b'문자가 나타나고 바로 뒤에 'c'문자가 나타나는 문자 조합에 대응됩니다. 문자열 "cbbabbbbcdebc"에서 위의 패턴은 부분 문자열 'abbbbc'와 대응합니다.

> `*`문자는 바로 앞의 문자가 0개 이상이라는 것을 의미합니다.
---
## 정규식에서의 특수 문자
|<center>Character</center>|<center>Meaning</center>|
|:--------:|:--------:|
|**`\`** | <center>특수문자가 아닌 문자 앞에서 사용된 백슬래시는 '해당 문자는 특별하고, 문자 그대로 해석되면 안된다.'는 사실을 가리킵니다. 예를 들어 `\가 없는 b`와 `\b`는 전혀 다른 문자가됩니다. 일반 소문자`b`는 다른 문자들과 대응하는 반면, `\b`는 어떠한 문자와도 대응되지 않습니다.<br><br>또한  특수문자 앞에 위치한 백슬래시는 '다음에 나오는 문자는 특별하지 않고, 문자 그대로 해석되어야 한다'는 사실을 가리킵니다. 예를 들어 패턴 `/a*/`에서 `*`은 0개 이상의 a문자가 등장함을 나타냅니다. 하지만 `/a\*/`에서는 문자 `a*`를 나타냅니다.<br><br>RegExp 표기법을 사용하면서 \ 자체를 사용하고 싶다면 `\\`이렇게 사용해야 합니다. 예를 들어 `/a\*/`와 같은 패턴을 사용하고 싶다면 RegExp 표기법에 따라서 `new RegExp('a\\*')`와 같이 사용해야 합니다. </center> |
|**`^`** | <center>입력의 시작부분에 대응됩니다. 만약 다중행 플래그가 참으로 설정되어있다면, 줄 바꿈 다음 부분과도 대응됩니다.<br><br>예를 들어 `/^A/`는 "an A"의 A와는 대응되지 않습니다. 그러나 "An E"와는 대응됩니다.</center> |
|**`$`** | <center>입력의 끝부분과 대응됩니다. 만약 다중행 플래그가 참으로 설정되어있다면, 줄 바꿈 문자의 바로 앞 부분과도 대응됩니다.<br><br> 예를들어 `/t$/`는 "eater"의 't'에는 대응되지 않습니다, 그러나 "eat"과는 대응됩니다.</center> |
|**`*`** | <center>앞의 표현식이 0회 이상 반복되는 부분과 대응됩니다. {0, } 와 같은 의미입니다. <br><br> 예를 들어 `/bo*/`는 "A ghost booooed" 의 'boooo' 와 대응되고, "A bird warbled" 의 'b'에 대응되지만 "A goat grunted" 내의 어느 부분과도 대응되지 않습니다.</center> |
|**`+`** | <center>앞의 표현식이 1회 이상 연속으로 반복되는 부분과 대응됩니다.<br><br> 예를 들어 `/a+/`는 "candy"의 a에 대응되고, "caaaaaaandy"의 모든 a에 대응됩니다. 하지만 "cndy"에선 대응되지 않습니다.</center> |
|**`?`** | <center>앞의 표현식이 0 또는 1회 이상 등장하는 부분과 대응됩니다. {0, 1 } 과 같은 의미입니다.<br><br>예를 들어 `/e?le?/`는 "angel"의 el과 대응하고 "angle"의 le에 대응 합니다. 또한 "also"의 l애 대응됩니다. <br><br> 만약 수량자(*, +, ?, {} ) 바로 뒤에 사용하면, 기본적으로 탐욕스럽던(가능한한 많이 대응) 수량자를 탐욕스럽지 않게(가능한한 적게 대응) 만듭니다. 예를 들어 `/\d+/`를 "123abc"에 적용시키면 "123"과 대응됩니다. (`\d`는 `[0-9]`사이의 숫자를 의미합니다.) 그러나 `/\d+?/`는 오직 '1'만 가르킵니다.<br><br>또한 이 문자는 `x(?=y)`와 `x(?!y)` 항목에서 설명하는 바와 같이 사전 검증을 위해서도 쓰입니다.</center> |
|**`.`** | <center>개행 문자를 제외한 모든 단일 문자와 대응됩니다. 쉽게 말하면 그냥 단일문자처럼 사용됩니다.<br><br>예를 들어, `/.n/`은 "nay, an apple is on the tree"에서 "an", "on"에 대응되지만, 'nay'에는 대응되지 않습니다.</center> |
|**`(x)`** | <center>x에 대응하고 그것을 기억합니다. 괄호는 포획괄호라고 부릅니다.<br><br>패턴 `/(foo) (bar) \1 \2/`안의 `(foo)`와 `(bar)`는 문자열 "foo bar foo bar"에서 처음의 두 단어에 대응되고 이를 기억합니다. 패턴 내부의 \1과 \2는 문자열의 마지막 두 단어에 대응됩니다. 왜냐하면 `\n`(n === Number)은 수에 따라 포획괄호의 순서를 알려줍니다. 그래서 저 예제에선 \1이 (foo)가 되고, \2가 (bar)가 되는 것 입니다. <br><br>`\n`문법은 정규식의 패턴 부분에서 사용됩니다. 정규식의 치환 부분에서는 `$1 $2 $n`과 같은 문법이 사용되어야 합니다. 예를 들어, `'bar foo'.replace( /(...) (...)/, '$2 $1')`와 같이 사용합니다. `$&` 패턴은 앞에서 대응된 전체 문자열을 가리킵니다.</center> |